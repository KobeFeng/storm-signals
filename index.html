<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Storm-signals : Storm primitives to allow out-of-band messaging to storm spouts and bolts." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Storm-signals</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/ptgoetz/storm-signals">Fork Me on GitHub</a>

          <h1 id="project_title">Storm-signals</h1>
          <h2 id="project_tagline">Storm primitives to allow out-of-band messaging to storm spouts and bolts.</h2>

          <section id="downloads">
            <a class="zip_download_link" href="https://github.com/ptgoetz/storm-signals/zipball/master">Download this project as a .zip file</a>
            <a class="tar_download_link" href="https://github.com/ptgoetz/storm-signals/tarball/master">Download this project as a tar.gz file</a>
          </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>Storm-Signals</h2>

<p>Storm-Signals aims to provide a way to send messages ("signals") to components (spouts/bolts) in a storm topology that are otherwise not addressable. </p>

<p>Storm topologies can be considered static in that modifications to a topology's behavior require redeployment. Storm-Signals provides a simple way to modify a topology's behavior at runtime, without redeployment.</p>

<h3>Project Location</h3>

<p>Primary development of storm-signals will take place at: 
<a href="https://github.com/ptgoetz/storm-signals">https://github.com/ptgoetz/storm-signals</a></p>

<p>Point/stable (non-SNAPSHOT) release souce code will be pushed to:
<a href="https://github.com/nathanmarz/storm-contrib">https://github.com/nathanmarz/storm-contrib</a></p>

<p>Maven artifacts for releases will be available on maven central.</p>

<h3>Use Cases</h3>

<p>Typical storm spouts run forever (until undeployed), emitting tuples based on an underlying, presumably event-driven, data source/stream.</p>

<p>Some storm users have expressed an interest in having more control over that pattern, for instance in situations where the data stream is not open-ended, or where the situation requires that data streams be controllable (i.e. the ability to start/stop/pause/resume processing).</p>

<p>Storm-Signals provides a very simple mechanism for communicating with spouts deployed within a storm topology. The communication mechanism resides outside of storm's basic stream processing paradigm (i.e. calls to <code>nextTuple()</code> and the tuple ack/fail mechanism).</p>

<p>Signals (messages)</p>

<h4>Sample Use Cases</h4>

<ul>
<li>Ability to start/stop/pause/resume a spout from a process <em>external to</em> the storm topology.</li>
<li>Ability to change the source of a spout's stream without redeploying the topology.</li>
<li>Initiating processing of a set/batch of data based on a schedule (such as a Quartz or cron job)</li>
<li>Periodically sending a dynamic SQL query to a spout that emits tuples for processing.</li>
<li>Any other use case you can think of. :)</li>
</ul><h2>Usage</h2>

<h3>Spout Implementation</h3>

<p>Currently (Version 0.1.0) provides a basic abstract <code>BaseRichSpout</code> implementation that must be subclassed:</p>

<p><code>backtype.storm.contrib.signals.spout.BaseSignalSpout</code></p>

<p>Subclasses <em>must</em> override the <code>onSignal()</code> method:</p>

<pre><code>protected abstract void onSignal(byte[] data);
</code></pre>

<p>This method is called when a signal is sent to a spout. The signal payload is a <code>byte[]</code> that can contain anything (string, data, seriliazed object(s), etc.).</p>

<p>Subclasses <em>must</em> override the superclass constructor:</p>

<pre><code>public TestSignalSpout(String name) {
    super(name);
}
</code></pre>

<p>The <code>name</code> parameter provides a unique ID for the spout that allows <code>SingalClient</code>s to address the bolt and send it messages.</p>

<p>Subclasses <em>must</em> call <code>super.open()</code> if they override the <code>open()</code> method: </p>

<pre><code>@Override
public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) {
    super.open(conf, context, collector);
}
</code></pre>

<p>Failure to do so will prevent the spout from receiving signals (i.e. <code>onSignal()</code> will never be called).</p>

<h3>Signal Client</h3>

<p>The <code>SignalClient</code> constructor requires two arguments:</p>

<ol>
<li>a zookeeper connect string ("host1:port1,host2:port2,hostN:portN") that should match the storm zookeeper configuration</li>
<li>a name string (this should match the name used to construct the <code>BaseSignalSpout</code> subclass)</li>
</ol><p>Example:</p>

<pre><code>public static void main(String[] args) throws Exception {
    SignalClient sc = new SignalClient("localhost:2181", "test-signal-spout");
    sc.start();
    try {
        sc.send("Hello Signal Spout!".getBytes());
    } finally {
        sc.close();
    }
}
</code></pre>

<h2>Maven Usage</h2>

<h3>Maven Dependency</h3>

<p>Point (non-SNAPSHOT) releases will be available on maven central.</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.github.ptgoetz&lt;/groupId&gt;
    &lt;artifactId&gt;storm-signals&lt;/artifactId&gt;
    &lt;version&gt;0.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Storm-signals maintained by <a href="https://github.com/ptgoetz">ptgoetz</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
